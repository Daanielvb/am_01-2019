# -*- coding: utf-8 -*-
"""Projeto1AM.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KIWksJfX23uneVeRbAWEgVa1biZRXHvP
"""

from datetime import datetime

import numpy as np
import pandas as pd
from sklearn.metrics import adjusted_rand_score

# algorithm parameters
K = 10  # number of partitions
m = 1.6  # fuzzification parameter
T = 150
e = 10e-10
p = 3  # number of views
n = 2000


def euclidean_distance(a, b):
    return np.linalg.norm(a - b)


def normalize_matrix(view):
    min_value = np.min(view)
    max_value = np.max(view)
    view = (view - min_value) / (max_value - min_value)
    return view


def dissimilarity_matrix(matrix, size):
    dis_matrix = np.zeros((size, size), dtype=float)
    for i in range(0, size):
        for j in range(0, size):
            dis_matrix[i, j] = euclidean_distance(a=matrix[i, :], b=matrix[j, :])
    return dis_matrix


def dist_object(i, k):
    acc = 0
    for j in range(0, p):
        acc += pesos[k][j] * dis_matrix[j][i][G[k][j]]
    return acc


def objective_function():
    objective = 0
    for k in range(0, K):
        for i in range(0, n):
            objective += np.power(U[i][k], m) * dist_object(i, k)
    return objective


def compute_u(i, k):
    membership = 0
    numerador = dist_object(i, k)
    for h in range(0, K):
        membership += np.power(numerador / dist_object(i, h), (1 / (m - 1)))
    membership = np.power(membership, -1)
    return membership


def crisp_partition():
    y = np.zeros(n, dtype=int)
    for i in range(0, n):
        y[i] = np.argmax(U[i])
    return y


def compute_weigths():
    for j in range(0, p):
        for k in range(0, K):
            numerador = 1
            for h in range(0, p):
                soma = 0
                for i in range(0, n):
                    soma += np.power(U[i][k], m) * dis_matrix[h][i][G[k][h]]
                numerador = numerador * soma
            numerador = np.power(numerador, (1 / p))
            denominador = 0
            for i in range(0, n):
                denominador += np.power(U[i][k], m) * dis_matrix[j][i][G[k][j]]
            pesos[k][j] = numerador/denominador
    return pesos


def compute_G():
    for k in range(0, K):
        for j in range(0, p):
            dist_vector = np.zeros(n, dtype=float)
            for h in range(0, n):
                soma = 0
                for i in range(0, n):
                    soma += np.power(U[i][k], m) * dis_matrix[j][i][h]
                dist_vector[h] = soma
            G[k][j] = np.argmin(dist_vector)
    return G

print('Começou:', datetime.now())
# importing datasets
fac_dataset = pd.read_csv('../data_bases/mfeat_fac.csv', header=None)
fou_dataset = pd.read_csv('../data_bases/mfeat_fou.csv', header=None)
kar_dataset = pd.read_csv('../data_bases/mfeat_kar.csv', header=None)
print('Carregou os arquivos')
# convert data frames to array
fac_view = fac_dataset.iloc[:, :].values
fou_view = fou_dataset.iloc[:, :].values
kar_view = kar_dataset.iloc[:, :].values

# Normalize matrixes (feature scaling)
fac_norm = normalize_matrix(fac_view)
fou_norm = normalize_matrix(fou_view)
kar_norm = normalize_matrix(kar_view)
print('Normalizou as matrizes')
# compute dissimilarity matrixes
fac_dis = dissimilarity_matrix(matrix=fac_norm, size=n)
print('Computou fac_dis')
fou_dis = dissimilarity_matrix(matrix=fou_norm, size=n)
print('Computou fou_dis')
kar_dis = dissimilarity_matrix(matrix=kar_norm, size=n)
print('Computou kar_dis')

dis_matrix = [fac_dis, fou_dis, kar_dis]
pesos = np.ones((K, p), dtype=float)
U = np.zeros((n, K), dtype=float)
G = np.random.choice(n, size=(K, p), replace=False)
# Partição à priori em 10 classes
y_priori = np.zeros(n, dtype=int)
y_priori[200:400] = 1
y_priori[400:600] = 2
y_priori[600:800] = 3
y_priori[800:1000] = 4
y_priori[1000:1200] = 5
y_priori[1200:1400] = 6
y_priori[1400:1600] = 7
y_priori[1600:1800] = 8
y_priori[1800:2000] = 9


print('-------------------Start loop: ', datetime.now(), '-------------------')
for i in range(0, n):
    for k in range(0, K):
        U[i][k] = compute_u(i, k)
J = objective_function()
print('Inicial J = ', J)
print('Inicial Prototipos ', G)
last_J = J + 10

t = 0
while (abs(J - last_J) >= e) and (t < T):
    last_J = J
    """Step 1"""
    G = compute_G()
    print('Prototipos ', G)
    """Step 2"""
    pesos = compute_weigths()
    print('Pesos ', pesos)
    """Step 3"""
    for i in range(0, n):
        for k in range(0, K):
            U[i][k] = compute_u(i, k)
    J = objective_function()
    print("U : ", U)
    t += 1
    print('------------------- Iteração: ', t, 'Valor função objetivo: ', J, '-------------------')

# Partição crisp considerando o U
y = crisp_partition()
print("Partição CRISP: ", y)
rand_score = adjusted_rand_score(y_priori, y)
print("Indice de Rand> ", rand_score)
print('Finalizou: ', datetime.now())
